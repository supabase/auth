package models

import (
	"database/sql"
	"time"

	"github.com/gofrs/uuid"
	"github.com/pkg/errors"
	"github.com/supabase/auth/internal/storage"
)

type SCIMGroup struct {
	ID            uuid.UUID          `db:"id" json:"id"`
	SSOProviderID uuid.UUID          `db:"sso_provider_id" json:"-"`
	ExternalID    storage.NullString `db:"external_id" json:"external_id,omitempty"`
	DisplayName   string             `db:"display_name" json:"display_name"`
	CreatedAt     time.Time `db:"created_at" json:"created_at"`
	UpdatedAt     time.Time `db:"updated_at" json:"updated_at"`

	SSOProvider *SSOProvider `belongs_to:"sso_providers" json:"-"`
	Members     []User       `many_to_many:"scim_group_members" json:"members,omitempty"`
}

func (SCIMGroup) TableName() string {
	return "scim_groups"
}

type SCIMGroupMember struct {
	GroupID   uuid.UUID `db:"group_id" json:"-"`
	UserID    uuid.UUID `db:"user_id" json:"-"`
	CreatedAt time.Time `db:"created_at" json:"-"`
}

func (SCIMGroupMember) TableName() string {
	return "scim_group_members"
}

func NewSCIMGroup(ssoProviderID uuid.UUID, externalID, displayName string) *SCIMGroup {
	id := uuid.Must(uuid.NewV4())
	group := &SCIMGroup{
		ID:            id,
		SSOProviderID: ssoProviderID,
		DisplayName:   displayName,
	}
	// Only set ExternalID if non-empty (NULL in DB otherwise)
	if externalID != "" {
		group.ExternalID = storage.NullString(externalID)
	}
	return group
}

func FindSCIMGroupByID(tx *storage.Connection, id uuid.UUID) (*SCIMGroup, error) {
	var group SCIMGroup
	if err := tx.Find(&group, id); err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, SCIMGroupNotFoundError{}
		}
		return nil, errors.Wrap(err, "error finding SCIM group by ID")
	}
	return &group, nil
}

func FindSCIMGroupByExternalID(tx *storage.Connection, ssoProviderID uuid.UUID, externalID string) (*SCIMGroup, error) {
	var group SCIMGroup
	if err := tx.Q().Where("sso_provider_id = ? AND external_id = ?", ssoProviderID, externalID).First(&group); err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, SCIMGroupNotFoundError{}
		}
		return nil, errors.Wrap(err, "error finding SCIM group by external ID")
	}
	return &group, nil
}

// SCIMFilterClause represents a parsed SCIM filter as SQL WHERE clause
type SCIMFilterClause struct {
	Where string
	Args  []interface{}
}

// FindSCIMGroupsBySSOProviderWithFilter finds groups with optional SCIM filter.
// The filterClause should be generated by ParseSCIMFilterToSQL.
func FindSCIMGroupsBySSOProviderWithFilter(tx *storage.Connection, ssoProviderID uuid.UUID, filterClause *SCIMFilterClause, startIndex, count int) ([]*SCIMGroup, int, error) {
	groups := []*SCIMGroup{}

	offset := startIndex - 1
	if offset < 0 {
		offset = 0
	}

	// Build query dynamically based on filter
	whereClause := "sso_provider_id = ?"
	args := []interface{}{ssoProviderID}

	if filterClause != nil && filterClause.Where != "" && filterClause.Where != "1=1" {
		whereClause += " AND (" + filterClause.Where + ")"
		args = append(args, filterClause.Args...)
	}

	var totalResults int
	countQuery := "SELECT COUNT(*) FROM scim_groups WHERE " + whereClause
	if err := tx.RawQuery(countQuery, args...).First(&totalResults); err != nil {
		return nil, 0, errors.Wrap(err, "error counting SCIM groups")
	}

	query := "SELECT * FROM scim_groups WHERE " + whereClause + " ORDER BY created_at ASC LIMIT ? OFFSET ?"
	args = append(args, count, offset)
	if err := tx.RawQuery(query, args...).All(&groups); err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return []*SCIMGroup{}, totalResults, nil
		}
		return nil, 0, errors.Wrap(err, "error finding SCIM groups")
	}
	return groups, totalResults, nil
}

func FindSCIMGroupsForUser(tx *storage.Connection, userID uuid.UUID) ([]*SCIMGroup, error) {
	groups := []*SCIMGroup{}
	if err := tx.RawQuery(`
		SELECT g.* FROM scim_groups g
		INNER JOIN scim_group_members m ON g.id = m.group_id
		WHERE m.user_id = ?
		ORDER BY g.display_name ASC
	`, userID).All(&groups); err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return []*SCIMGroup{}, nil
		}
		return nil, errors.Wrap(err, "error finding SCIM groups for user")
	}
	return groups, nil
}

func (g *SCIMGroup) AddMember(tx *storage.Connection, userID uuid.UUID) error {
	user, err := FindUserByID(tx, userID)
	if err != nil {
		return err
	}

	if !userBelongsToSSOProvider(user, g.SSOProviderID) {
		return UserNotInSSOProviderError{}
	}

	return tx.RawQuery(
		"INSERT INTO scim_group_members (group_id, user_id, created_at) VALUES (?, ?, ?) ON CONFLICT DO NOTHING",
		g.ID, userID, time.Now(),
	).Exec()
}

func userBelongsToSSOProvider(user *User, ssoProviderID uuid.UUID) bool {
	providerType := "sso:" + ssoProviderID.String()
	for _, identity := range user.Identities {
		if identity.Provider == providerType {
			return true
		}
	}
	return false
}

func (g *SCIMGroup) RemoveMember(tx *storage.Connection, userID uuid.UUID) error {
	return tx.RawQuery(
		"DELETE FROM scim_group_members WHERE group_id = ? AND user_id = ?",
		g.ID, userID,
	).Exec()
}

func (g *SCIMGroup) GetMembers(tx *storage.Connection) ([]*User, error) {
	users := []*User{}
	if err := tx.RawQuery(`
		SELECT u.* FROM users u
		INNER JOIN scim_group_members m ON u.id = m.user_id
		WHERE m.group_id = ?
		ORDER BY u.email ASC
	`, g.ID).All(&users); err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return []*User{}, nil
		}
		return nil, errors.Wrap(err, "error getting SCIM group members")
	}
	return users, nil
}

func (g *SCIMGroup) SetMembers(tx *storage.Connection, userIDs []uuid.UUID) error {
	if err := tx.RawQuery("DELETE FROM scim_group_members WHERE group_id = ?", g.ID).Exec(); err != nil {
		return errors.Wrap(err, "error clearing SCIM group members")
	}

	for _, userID := range userIDs {
		if err := g.AddMember(tx, userID); err != nil {
			if IsNotFoundError(err) {
				// Skip non-existent users silently per SCIM best practice
				continue
			}
			// Skip users that don't belong to this provider silently
			if _, ok := err.(UserNotInSSOProviderError); ok {
				continue
			}
			return errors.Wrap(err, "error adding SCIM group member")
		}
	}
	return nil
}

