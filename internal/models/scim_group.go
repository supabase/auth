package models

import (
	"database/sql"
	"strings"
	"time"

	"github.com/gobuffalo/pop/v6"
	"github.com/gofrs/uuid"
	"github.com/pkg/errors"
	"github.com/supabase/auth/internal/storage"
)

func scimGroupTableName() string {
	return (&pop.Model{Value: SCIMGroup{}}).TableName()
}

func scimGroupMemberTableName() string {
	return (&pop.Model{Value: SCIMGroupMember{}}).TableName()
}

type SCIMGroup struct {
	ID            uuid.UUID          `db:"id" json:"id"`
	SSOProviderID uuid.UUID          `db:"sso_provider_id" json:"-"`
	ExternalID    storage.NullString `db:"external_id" json:"external_id,omitempty"`
	DisplayName   string             `db:"display_name" json:"display_name"`
	CreatedAt     time.Time          `db:"created_at" json:"created_at"`
	UpdatedAt     time.Time          `db:"updated_at" json:"updated_at"`

	SSOProvider *SSOProvider `belongs_to:"sso_providers" json:"-"`
	Members     []User       `many_to_many:"scim_group_members" json:"members,omitempty"`
}

func (SCIMGroup) TableName() string {
	return "scim_groups"
}

type SCIMGroupMember struct {
	GroupID   uuid.UUID `db:"group_id" json:"-"`
	UserID    uuid.UUID `db:"user_id" json:"-"`
	CreatedAt time.Time `db:"created_at" json:"-"`
}

func (SCIMGroupMember) TableName() string {
	return "scim_group_members"
}

func NewSCIMGroup(ssoProviderID uuid.UUID, externalID, displayName string) *SCIMGroup {
	id := uuid.Must(uuid.NewV4())
	group := &SCIMGroup{
		ID:            id,
		SSOProviderID: ssoProviderID,
		DisplayName:   displayName,
	}
	// Only set ExternalID if non-empty (NULL in DB otherwise)
	if externalID != "" {
		group.ExternalID = storage.NullString(externalID)
	}
	return group
}

func FindSCIMGroupByID(tx *storage.Connection, id uuid.UUID) (*SCIMGroup, error) {
	var group SCIMGroup
	if err := tx.Find(&group, id); err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, SCIMGroupNotFoundError{}
		}
		return nil, errors.Wrap(err, "error finding SCIM group by ID")
	}
	return &group, nil
}

func FindSCIMGroupByExternalID(tx *storage.Connection, ssoProviderID uuid.UUID, externalID string) (*SCIMGroup, error) {
	var group SCIMGroup
	if err := tx.Q().Where("sso_provider_id = ? AND external_id = ?", ssoProviderID, externalID).First(&group); err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, SCIMGroupNotFoundError{}
		}
		return nil, errors.Wrap(err, "error finding SCIM group by external ID")
	}
	return &group, nil
}

// SCIMFilterClause represents a parsed SCIM filter as SQL WHERE clause
type SCIMFilterClause struct {
	Where string
	Args  []interface{}
}

// FindSCIMGroupsBySSOProviderWithFilter finds groups with optional SCIM filter.
// The filterClause should be generated by ParseSCIMFilterToSQL.
func FindSCIMGroupsBySSOProviderWithFilter(tx *storage.Connection, ssoProviderID uuid.UUID, filterClause *SCIMFilterClause, startIndex, count int) ([]*SCIMGroup, int, error) {
	groups := []*SCIMGroup{}

	offset := startIndex - 1
	if offset < 0 {
		offset = 0
	}

	// Build query dynamically based on filter
	whereClause := "sso_provider_id = ?"
	args := []interface{}{ssoProviderID}

	if filterClause != nil && filterClause.Where != "" && filterClause.Where != "1=1" {
		whereClause += " AND (" + filterClause.Where + ")"
		args = append(args, filterClause.Args...)
	}

	var totalResults int
	countQuery := "SELECT COUNT(*) FROM " + scimGroupTableName() + " WHERE " + whereClause
	if err := tx.RawQuery(countQuery, args...).First(&totalResults); err != nil {
		return nil, 0, errors.Wrap(err, "error counting SCIM groups")
	}

	query := "SELECT * FROM " + scimGroupTableName() + " WHERE " + whereClause + " ORDER BY created_at ASC LIMIT ? OFFSET ?"
	args = append(args, count, offset)
	if err := tx.RawQuery(query, args...).All(&groups); err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return []*SCIMGroup{}, totalResults, nil
		}
		return nil, 0, errors.Wrap(err, "error finding SCIM groups")
	}
	return groups, totalResults, nil
}

func FindSCIMGroupsForUser(tx *storage.Connection, userID uuid.UUID) ([]*SCIMGroup, error) {
	groups := []*SCIMGroup{}
	if err := tx.RawQuery(
		"SELECT g.* FROM "+scimGroupTableName()+" g INNER JOIN "+scimGroupMemberTableName()+" m ON g.id = m.group_id WHERE m.user_id = ? ORDER BY g.display_name ASC",
		userID,
	).All(&groups); err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return []*SCIMGroup{}, nil
		}
		return nil, errors.Wrap(err, "error finding SCIM groups for user")
	}
	return groups, nil
}

func (g *SCIMGroup) AddMember(tx *storage.Connection, userID uuid.UUID) error {
	user, err := FindUserByID(tx, userID)
	if err != nil {
		return err
	}

	if !UserBelongsToSSOProvider(user, g.SSOProviderID) {
		return UserNotInSSOProviderError{}
	}

	return tx.RawQuery(
		"INSERT INTO "+scimGroupMemberTableName()+" (group_id, user_id, created_at) VALUES (?, ?, ?) ON CONFLICT DO NOTHING",
		g.ID, userID, time.Now(),
	).Exec()
}

// UserBelongsToSSOProvider checks if a user has an identity linked to the specified SSO provider.
func UserBelongsToSSOProvider(user *User, ssoProviderID uuid.UUID) bool {
	providerType := "sso:" + ssoProviderID.String()
	for _, identity := range user.Identities {
		if identity.Provider == providerType {
			return true
		}
	}
	return false
}

func (g *SCIMGroup) AddMembers(tx *storage.Connection, userIDs []uuid.UUID) error {
	if len(userIDs) == 0 {
		return nil
	}

	identityTable := (&pop.Model{Value: Identity{}}).TableName()
	userTable := (&pop.Model{Value: User{}}).TableName()
	providerType := "sso:" + g.SSOProviderID.String()

	placeholders := make([]string, len(userIDs))
	queryArgs := make([]interface{}, len(userIDs))
	for i, id := range userIDs {
		placeholders[i] = "?"
		queryArgs[i] = id
	}
	inClause := strings.Join(placeholders, ",")

	var rawValidIDs []uuid.UUID
	validationArgs := make([]interface{}, 0, len(userIDs)+1)
	validationArgs = append(validationArgs, queryArgs...)
	validationArgs = append(validationArgs, providerType)
	if err := tx.RawQuery(
		"SELECT u.id FROM "+userTable+" u "+
			"INNER JOIN "+identityTable+" i ON i.user_id = u.id "+
			"WHERE u.id IN ("+inClause+") AND i.provider = ? "+
			"FOR SHARE OF u, i",
		validationArgs...,
	).All(&rawValidIDs); err != nil {
		return errors.Wrap(err, "error validating SCIM group member IDs")
	}

	validSet := make(map[uuid.UUID]struct{}, len(rawValidIDs))
	for _, id := range rawValidIDs {
		validSet[id] = struct{}{}
	}

	if len(validSet) != len(userIDs) {
		for _, id := range userIDs {
			if _, ok := validSet[id]; !ok {
				if _, err := FindUserByID(tx, id); err != nil {
					if IsNotFoundError(err) {
						return UserNotFoundError{}
					}
					return errors.Wrap(err, "error looking up user for SCIM group membership")
				}
				return UserNotInSSOProviderError{}
			}
		}
	}

	now := time.Now()
	insertArgs := make([]interface{}, 0, 2+len(userIDs)+1)
	insertArgs = append(insertArgs, g.ID, now)
	insertArgs = append(insertArgs, queryArgs...)
	insertArgs = append(insertArgs, providerType)

	if err := tx.RawQuery(
		"INSERT INTO "+scimGroupMemberTableName()+" (group_id, user_id, created_at) "+
			"SELECT ?, u.id, ? FROM "+userTable+" u "+
			"INNER JOIN "+identityTable+" i ON i.user_id = u.id "+
			"WHERE u.id IN ("+inClause+") AND i.provider = ? "+
			"ON CONFLICT DO NOTHING",
		insertArgs...,
	).Exec(); err != nil {
		return errors.Wrap(err, "error adding SCIM group members")
	}
	return nil
}

func (g *SCIMGroup) RemoveMember(tx *storage.Connection, userID uuid.UUID) error {
	return tx.RawQuery(
		"DELETE FROM "+scimGroupMemberTableName()+" WHERE group_id = ? AND user_id = ?",
		g.ID, userID,
	).Exec()
}

func (g *SCIMGroup) GetMembers(tx *storage.Connection) ([]*User, error) {
	users := []*User{}
	userTable := (&pop.Model{Value: User{}}).TableName()
	if err := tx.RawQuery(
		"SELECT u.* FROM "+userTable+" u INNER JOIN "+scimGroupMemberTableName()+" m ON u.id = m.user_id WHERE m.group_id = ? ORDER BY u.email ASC",
		g.ID,
	).All(&users); err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return []*User{}, nil
		}
		return nil, errors.Wrap(err, "error getting SCIM group members")
	}
	return users, nil
}

func (g *SCIMGroup) SetMembers(tx *storage.Connection, userIDs []uuid.UUID) error {
	if len(userIDs) == 0 {
		if err := tx.RawQuery("DELETE FROM "+scimGroupMemberTableName()+" WHERE group_id = ?", g.ID).Exec(); err != nil {
			return errors.Wrap(err, "error clearing SCIM group members")
		}
		return nil
	}

	identityTable := (&pop.Model{Value: Identity{}}).TableName()
	userTable := (&pop.Model{Value: User{}}).TableName()
	providerType := "sso:" + g.SSOProviderID.String()

	placeholders := make([]string, len(userIDs))
	queryArgs := make([]interface{}, len(userIDs))
	for i, id := range userIDs {
		placeholders[i] = "?"
		queryArgs[i] = id
	}
	inClause := strings.Join(placeholders, ",")

	var rawValidIDs []uuid.UUID
	validationArgs := make([]interface{}, 0, len(userIDs)+1)
	validationArgs = append(validationArgs, queryArgs...)
	validationArgs = append(validationArgs, providerType)
	// Lock both user and identity rows during validation to prevent concurrent
	// deletion or identity changes between validation and the membership write.
	// DISTINCT is omitted because PostgreSQL disallows row-locking with DISTINCT;
	// de-duplication is done in Go below.
	if err := tx.RawQuery(
		"SELECT u.id FROM "+userTable+" u "+
			"INNER JOIN "+identityTable+" i ON i.user_id = u.id "+
			"WHERE u.id IN ("+inClause+") AND i.provider = ? "+
			"FOR SHARE OF u, i",
		validationArgs...,
	).All(&rawValidIDs); err != nil {
		return errors.Wrap(err, "error validating SCIM group member IDs")
	}

	// De-duplicate IDs in Go since we cannot use DISTINCT with FOR SHARE.
	validSet := make(map[uuid.UUID]struct{}, len(rawValidIDs))
	for _, id := range rawValidIDs {
		validSet[id] = struct{}{}
	}

	if len(validSet) != len(userIDs) {
		for _, id := range userIDs {
			if _, ok := validSet[id]; !ok {
				if _, err := FindUserByID(tx, id); err != nil {
					if IsNotFoundError(err) {
						return UserNotFoundError{}
					}
					return errors.Wrap(err, "error looking up user for SCIM group membership")
				}
				return UserNotInSSOProviderError{}
			}
		}
	}

	if err := tx.RawQuery("DELETE FROM "+scimGroupMemberTableName()+" WHERE group_id = ?", g.ID).Exec(); err != nil {
		return errors.Wrap(err, "error clearing SCIM group members")
	}

	now := time.Now()
	insertArgs := make([]interface{}, 0, 2+len(userIDs)+1)
	insertArgs = append(insertArgs, g.ID, now)
	insertArgs = append(insertArgs, queryArgs...)
	insertArgs = append(insertArgs, providerType)

	if err := tx.RawQuery(
		"INSERT INTO "+scimGroupMemberTableName()+" (group_id, user_id, created_at) "+
			"SELECT ?, u.id, ? FROM "+userTable+" u "+
			"INNER JOIN "+identityTable+" i ON i.user_id = u.id "+
			"WHERE u.id IN ("+inClause+") AND i.provider = ? "+
			"ON CONFLICT DO NOTHING",
		insertArgs...,
	).Exec(); err != nil {
		return errors.Wrap(err, "error setting SCIM group members")
	}
	return nil
}

func GetMembersForGroups(tx *storage.Connection, groupIDs []uuid.UUID) (map[uuid.UUID][]*User, error) {
	result := make(map[uuid.UUID][]*User)
	if len(groupIDs) == 0 {
		return result, nil
	}

	userTable := (&pop.Model{Value: User{}}).TableName()

	type memberRow struct {
		GroupID uuid.UUID `db:"group_id"`
		User
	}

	placeholders := make([]string, len(groupIDs))
	args := make([]interface{}, len(groupIDs))
	for i, id := range groupIDs {
		placeholders[i] = "?"
		args[i] = id
	}

	rows := []memberRow{}
	if err := tx.RawQuery(
		"SELECT m.group_id, u.* FROM "+userTable+" u "+
			"INNER JOIN "+scimGroupMemberTableName()+" m ON u.id = m.user_id "+
			"WHERE m.group_id IN ("+strings.Join(placeholders, ",")+") "+
			"ORDER BY u.email ASC",
		args...,
	).All(&rows); err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return result, nil
		}
		return nil, errors.Wrap(err, "error batch loading SCIM group members")
	}

	for i := range rows {
		result[rows[i].GroupID] = append(result[rows[i].GroupID], &rows[i].User)
	}
	return result, nil
}
